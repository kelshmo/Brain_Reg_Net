---
title: Covariate analysis of HBCC RNASeq data reprocessed with STAR-feature counts workflow with Ensembl v75 (ACC and DLPFC with CQN + SVA normlaisation)
author: Thanneer Perumal
editor_options:
  chunk_output_type: console
---
Date of analysis update: "`r date()`"

```{r knit2synapse, eval=FALSE}
library(synapseClient)
library(knit2synapse)

synapseLogin()

knit2synapse::knitToFolderEntity(file = "./HBCC_DLPFC_STAR_ENSEMBL_v75_CQN_SVA.Rmd",
                                 parentId = "syn7501880", #"syn9872607",
                                 entityName = 'HBCC - DLPFC - STAR - FEATURE COUNTS - ENSEMBL v75 - CQN - SVA')
```

```{r libs, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}
## It is assumed your working directory is where this file

## Load required libraries
library(CovariateAnalysis) # get the package from devtools::install_github('th1vairam/CovariateAnalysis@dev')
library(data.table)
library(tidyr)
library(plyr)
library(dplyr)
library(stringr)

library(ggplot2)
library(limma)
library(psych)
library(edgeR)
library(cqn)
library(lme4)
library(biomaRt)

library(synapseClient)
library(knitr)
library(githubr) # get the package from devtools::install_github('brian-bot/githubr')

synapseLogin()

library(doParallel)
library(foreach)

cl = makeCluster(detectCores()-2)
registerDoParallel(cl)

# Source modified functions from sva package
source('../R/irwsva.build.R')
source('../R/f.pvalue.R')

options(xtable.type="html")

knitr::opts_chunk$set(
  echo=FALSE,
  warning=FALSE,
  message=FALSE,
  error = FALSE,
  tidy = FALSE,
  cache = TRUE)
```

```{r synapse.parameters, include=FALSE, cache=TRUE}
parentId = "syn7501880", #'syn9872607';
activityName = 'Covariate adjustments';
activityDescription = 'Covariate analysis of STAR aligned feature counts with Ensembl v75 with CQN and SVA normalisation (DLPFC)';

thisFileName <- 'HBCC_DLPFC_STAR_ENSEMBL_v75_CQN_SVA.Rmd'

# Github link
thisRepo <- getRepo(repository = "th1vairam/Brain_Reg_Net", ref="branch", refName='CMC')
thisFile <- getPermlink(repository = thisRepo, repositoryPath=paste0('code/Rmd/',thisFileName))
```
### Data preprocessing
```{r preprocess.data}
# Remove samples marked as exclude and samples with no Gender, Ethnicity, PMI, and RIN
writeLines('Following counts are missing any metadata')
writeLines(paste(setdiff(colnames(COUNT), METADATA$SampleID), collapse = ', '))
METADATA <- METADATA %>% dplyr::filter(SampleID %in% colnames(COUNT)) 

writeLines('Following samples are marked exclude')
writeLines(paste(METADATA$SampleID[METADATA$label == 'exclude'], collapse = ', '))
METADATA <- METADATA  %>% dplyr::filter(label == 'accept') 

writeLines('Following samples are missing PMI information')
writeLines(paste(METADATA$SampleID[is.na(METADATA$PMI)], collapse = ', '))
METADATA <- METADATA  %>% dplyr::filter(!is.na(PMI)) 

writeLines('Following samples are missing gender information')
writeLines(paste(METADATA$SampleID[is.na(METADATA$Gender)], collapse = ', '))
METADATA <- METADATA  %>% dplyr::filter(!is.na(Gender)) 

writeLines('Following samples are missing RIN information')
writeLines(paste(METADATA$SampleID[is.na(METADATA$RIN)], collapse = ', '))
METADATA <- METADATA  %>% dplyr::filter(!is.na(RIN)) 

writeLines(paste('Following',length(METADATA$SampleID[is.na(METADATA$TotalReads)]), 'samples are missing RNASeq QC metrics:'))
writeLines(paste(METADATA$SampleID[is.na(METADATA$TotalReads)], collapse = ', '))
METADATA <- METADATA  %>% dplyr::filter(!is.na(TotalReads)) 

writeLines('Some control samples with Age of death less than 18 are removed')
writeLines(paste('Following',length(METADATA$SampleID[METADATA$Age_of_Death <= 18]), 'samples are removed:'))
writeLines(paste(METADATA$SampleID[METADATA$Age_of_Death <= 18], collapse = ', '))
METADATA <- METADATA  %>% dplyr::filter(Age_of_Death >= 18)
```

```{r preprocess.data1, results='asis'}
# Match covariates to expression data
indToRetain = intersect(METADATA$SampleID, colnames(COUNT))
removedIDs = setdiff(colnames(COUNT), METADATA$SampleID)

COUNT = COUNT[,indToRetain]

rownames(METADATA) = METADATA$SampleID
METADATA = METADATA[indToRetain,]

METADATA %>% 
  dplyr::group_by(Dx) %>% 
  dplyr::summarise(count = n()) %>%
  kable()

METADATA = METADATA %>%
  dplyr::mutate(Dx.Tissue = paste(Dx, Tissue, sep = '.'))
```
Following `r length(removedIDs)` sample are removed `r paste(removedIDs, collapse = ',')`

```{r gene.param, include = FALSE}
## Get GC content from biomart
backgroundGenes = data.frame(ensembl_gene_id = rownames(COUNT))

# Define biomart object
mart <- useMart(biomart = "ENSEMBL_MART_ENSEMBL", host = "dec2016.archive.ensembl.org", dataset = "hsapiens_gene_ensembl")

# Query biomart
Ensemble2HGNC <- getBM(attributes = c("ensembl_gene_id", "hgnc_symbol", "percentage_gc_content", "gene_biotype"),
                       filters = "ensembl_gene_id", values = backgroundGenes$ensembl_gene_id,
                       mart = mart)

GENE.GC.CONT = Ensemble2HGNC %>%
  dplyr::select(ensembl_gene_id, percentage_gc_content) %>%
  unique
rownames(GENE.GC.CONT) = GENE.GC.CONT$ensembl_gene_id
```

### Covariates clustering
Determine relationship between covariates. 
```{r covariates.clustering}
FactorCovariates <- c("Gender", "Dx.Tissue", "LibraryBatch", "RibozeroBatch", "FlowcellBatch")
ContCovariates <- c("Age_of_Death", "PMI", "RIN", "TotalReads", "X5prime_Norm", "Mean_Per_Base_Cov.",
                    "Mean_CV", "Fragment_Length_StdDev", "Mapped_Pairs", "End_1_Mismatch_Rate",
                    "End_2_Mismatch_Rate", "Mapped", "IntragenicRate", "ExonicRate", "IntergenicRate",
                    "IntronicRate", "rRNARate", "GenesDetected", "TranscriptsDetected", "ExpProfEfficiency",   
                    "PercentMapped")

# Find inter relation between factor covariates
COVARIATES = METADATA[,c(FactorCovariates,ContCovariates),drop=F]
COVARIATES[,FactorCovariates] <- data.frame(lapply(COVARIATES[,FactorCovariates],function(x){
  x <- sapply(x,function(y){str_replace_all(as.character(y),'[^[:alnum:]]','_')})}))
rownames(COVARIATES) <- METADATA$SampleID

# Convert factor covariates to factors
COVARIATES[,FactorCovariates] = lapply(COVARIATES[,FactorCovariates], factor)
COVARIATES[,ContCovariates] = lapply(COVARIATES[,ContCovariates], function(x){
  x = as.numeric(as.character(gsub('[\\,\\%]','',x)))
})

# Add in RIN^2 values
COVARIATES$RIN2 = COVARIATES$RIN^2
ContCovariates = c(ContCovariates, 'RIN2')
```
Correlation/association between covariates at an FDR <= 0.1
```{r covariates.correlation, fig.width=15, fig.height=15}
COVARIATES.CORRELATION = getAssociationStatistics(COVARIATES, PVAL = 0.05)
tmp = COVARIATES.CORRELATION$ESTIMATE
tmp[COVARIATES.CORRELATION$PVAL > 0.05] = 0
fdr = COVARIATES.CORRELATION$PVAL
fdr = format(fdr, digits=1)
h = Heatmap(tmp, col = colorRamp2(c(-1,0,1), c('blue','white','red')), name = 'AssocEstimate',
            cell_fun = function(j,i,x,y,wifht,height,fill){
              grid.text(fdr[i,j], x, y)
            })
draw(h, heatmap_legend_side = 'left', padding = unit(c(10,2,2,10), "mm"))
```

## Explore metatdata
```{r data.explore, fig.width = 12, fig.height = 12}
my.theme <- theme(legend.position = 'top', axis.text.x = element_text(angle = 90, hjust = 1), plot.title=element_text(hjust=0.5))

# RIN
p = list()
p[[1]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = RIN)) + geom_boxplot()
p[[1]] = p[[1]] + ggtitle('RIN') + my.theme

# Age of Death
p[[2]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = Age_of_Death)) + geom_boxplot()
p[[2]] = p[[2]] + ggtitle('AgeOfDeath') + my.theme

# PMI
p[[3]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = PMI)) + geom_boxplot()
p[[3]] = p[[3]] + ggtitle('PMI (in hours)') + my.theme

# Intronic Rate
p[[4]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = IntronicRate)) + geom_boxplot()
p[[4]] = p[[4]] + ggtitle('Intronic Rate') + my.theme

# IntergenicRate
p[[5]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = IntergenicRate)) + geom_boxplot()
p[[5]] = p[[5]] + ggtitle('Intergenic Rate') + my.theme

# Transcripts Detected
p[[6]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = TranscriptsDetected)) + geom_boxplot()
p[[6]] = p[[6]] + ggtitle('Transcripts Detected') + my.theme

# Mapped Reads
p[[7]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = Mapped)) + geom_boxplot()
p[[7]] = p[[7]] + ggtitle('Mapped Reads') + my.theme

# ExonicRate
p[[8]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = ExonicRate)) + geom_boxplot()
p[[8]] = p[[8]] + ggtitle('Exonic Rate') + my.theme

# rRNARate
p[[9]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = rRNARate)) + geom_boxplot()
p[[9]] = p[[9]] + ggtitle('rRNARate') + my.theme

multiplot(plotlist = p, cols = 3)

# Institution
# vcd::mosaic(~ Institution + Dx.Tissue, data = COVARIATES)

# Gender
# vcd::mosaic(~ Gender + Dx.Tissue, data = COVARIATES)
```
### Filter genes
Remove genes that have less than 1 cpm counts in at least 50% of samples per Dx.Tissue. Also remove genes with missing gene length and percentage GC content
```{r cpmnormalisation}
COUNT = COUNT[setdiff(rownames(COUNT), 'Geneid'),]
genesToAnalyze = dlply(METADATA, .(Dx.Tissue), .fun = function(mtd, count){
  processed.counts = getGeneFilteredGeneExprMatrix(count[,mtd$SampleID],
                                                   MIN_GENE_CPM=1, 
                                                   MIN_SAMPLE_PERCENT_WITH_MIN_GENE_CPM=0.5)
  processed.counts$filteredExprMatrix$genes
}, COUNT)

genesToAnalyze = unlist(genesToAnalyze) %>% 
  unique() %>%
  intersect(GENE.GC.CONT$ensembl_gene_id[!is.na(GENE.GC.CONT$percentage_gc_content)]) %>%
  intersect(GENE.LEN$ensembl_gene_id[!is.na(GENE.LEN$Length)])

PROCESSED_COUNTS = getGeneFilteredGeneExprMatrix(COUNT[genesToAnalyze, ], MIN_GENE_CPM=0, MIN_SAMPLE_PERCENT_WITH_MIN_GENE_CPM=0)
pct.pc = PROCESSED_COUNTS$filteredExprMatrix$genes %>%
  dplyr::rename(ensembl_gene_id = genes) %>%
  dplyr::left_join(Ensemble2HGNC) %>%
  dplyr::group_by(gene_biotype) %>%
  dplyr::summarise(fraction  = n()) %>%
  dplyr::filter(fraction > 100) %>%
  dplyr::mutate(fraction = fraction/length(PROCESSED_COUNTS$filteredExprMatrix$genes[,1]))
```
`r dim(PROCESSED_COUNTS$filteredExprMatrix$genes)[1]` genes are used for the analysis. 

Following is the distribution of biotypes
`r kable(pct.pc)`

### Outlier analysis
Detect outlier samples based on their expression (logCPM) pattern
```{r detect.outliers, fig.height=8, fig.width=8, results='asis', cache = FALSE}
indToRemove = c("CMC_HBCC_RNA_PFC_3402")

# Find principal components of expression to plot
PC <- prcomp(voom(PROCESSED_COUNTS$filteredExprMatrix$counts)$E, scale.=T, center = T)

# Plot first 2 PCs
plotdata <- data.frame(SampleID=rownames(PC$rotation), 
                       PC1=PC$rotation[,1], 
                       PC2=PC$rotation[,2])

plotdata <- left_join(plotdata, rownameToFirstColumn(COVARIATES, 'SampleID')) %>%
  tidyr::separate(Dx.Tissue, c('Dx','Tissue'), sep = '_') %>%
  dplyr::mutate(label = SampleID)
plotdata$label[!(plotdata$SampleID %in% indToRemove)] = ''
plotdata$label[plotdata$Age_of_Death <= 21] = plotdata$SampleID[plotdata$Age_of_Death <= 21]

p <- ggplot(plotdata, aes(x=PC1, y=PC2))
p <- p + geom_point(aes(color=Gender, shape=Dx, size=Age_of_Death))
p <- p + theme_bw() + theme(legend.position="right") + facet_grid(Tissue~.)
p <- p + geom_text(aes(label= label), size=4, hjust=0)
p

# Plot abberent distribution of logcpm counts
tmp1 = voom(PROCESSED_COUNTS$filteredExprMatrix$counts)$E %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  tidyr::gather(SampleID, logCPM, -ensembl_gene_id) %>%
  left_join(COVARIATES %>%
              rownameToFirstColumn('SampleID') %>%
              tidyr::separate(Dx.Tissue, c('Dx', 'Tissue'), sep = '_'))

p = ggplot(tmp1 %>%
             dplyr::filter(SampleID %in% indToRemove),
           aes(x = logCPM, color = SampleID)) + geom_density() 
p = p + theme(legend.position = 'top') + facet_grid(Dx+.~Tissue, scale = 'free')
p

indToRetain = setdiff(colnames(PROCESSED_COUNTS$filteredExprMatrix$counts), indToRemove)
PROCESSED_COUNTS$filteredExprMatrix$counts = PROCESSED_COUNTS$filteredExprMatrix$counts[,indToRetain]
COVARIATES = COVARIATES[indToRetain,]

tmp = tidyr::separate(COVARIATES, Dx.Tissue, c('Dx', 'Tissue'), sep = '_') %>%
  dplyr::group_by(Dx, Tissue) %>%
  dplyr::summarise(count = n()) %>%
  tidyr::spread(Tissue, count)
```
Processing `r dim(PROCESSED_COUNTS$filteredExprMatrix)[1]` genes in `r dim(PROCESSED_COUNTS$filteredExprMatrix)[2]` samples

Based on the expression pattern following samples were tagged as outliers: `r paste(indToRemove, collapse = ', ')` 

Distribution of samples are:
`r kable(tmp)`

### Library Normalisation and Winsorise data
Initial library normalisation usign cqn and setting gene outliers to NA
```{r cqn}
# Compute offset for gene length and gc content
CQN.GENE_EXPRESSION = cqn(PROCESSED_COUNTS$filteredExprMatrix$counts, 
                          x = GENE.GC.CONT[PROCESSED_COUNTS$filteredExprMatrix$genes$genes, 'percentage_gc_content'],
                          lengths = as.numeric(GENE.LEN[PROCESSED_COUNTS$filteredExprMatrix$genes$genes, 'Length']),
                          lengthMethod = "smooth", 
                          verbose = FALSE)
CQN.GENE_EXPRESSION$E = CQN.GENE_EXPRESSION$y + CQN.GENE_EXPRESSION$offset

# Set gene counts in specific samples that are deviating 3 sd from other samples to 3SD limit
CQN.GENE_EXPRESSION$E = apply(CQN.GENE_EXPRESSION$E, 1, function(x){
  mn = mean(x, na.rm = T)
  std.dev = sd(x, na.rm = T)
  
  ind.low = which(x == max(x[which(x <= mn-3*std.dev)], na.rm = T))
  ind.high = which(x == min(x[which(x >= mn+3*std.dev)], na.rm = T))
  
  x[x < (mn-3*std.dev)] = NA
  x[x > (mn+3*std.dev)] = NA
  return(x)
}) %>% t

# Back calculate counts for further analysis
LIB.SIZE = colSums(PROCESSED_COUNTS$filteredExprMatrix$counts)
NEW.COUNTS = (2^CQN.GENE_EXPRESSION$E) * t(replicate(dim(CQN.GENE_EXPRESSION$E)[1], LIB.SIZE))/1e6
```

### Co-expression distribution
Coexpression of genes 
```{r coexp1, cache=FALSE, fig.height=5, fig.width=5}
tmp = CQN.GENE_EXPRESSION$E
tmp[is.na(tmp)] = 0
cr = cor(t(tmp))
hist(cr, main = 'Distribution of correlation between genes', xlab = 'Correlation')
```

### Sample clustering
```{r decompse.normalise.data, fig.height=8, fig.width=8, results='asis', cache=FALSE}
# Find principal components of expression to plot
tmp = CQN.GENE_EXPRESSION$E
tmp[is.na(tmp)] = 0
PC <- prcomp(tmp, scale.=T, center = T)

# Plot first 2 PCs
plotdata <- data.frame(SampleID=rownames(PC$rotation), 
                       PC1=PC$rotation[,1], 
                       PC2=PC$rotation[,2])

plotdata <- left_join(plotdata, rownameToFirstColumn(COVARIATES, 'SampleID')) %>%
  tidyr::separate(Dx.Tissue, c('Dx','Tissue'), sep = '_')

p <- ggplot(plotdata, aes(x=PC1, y=PC2))
p <- p + geom_point(aes(color=Gender, shape=Tissue, size=Age_of_Death))
p <- p + theme_bw() + theme(legend.position="right") + facet_grid(Tissue~.)
# p <- p + geom_text(aes(label= SampleID), size=4, hjust=0)
p
```
Tree based clustering of samples
```{r decompse.normalise.data.1, fig.height=6, fig.width=10, results='asis'}
# Eucledian tree based analysis
COVARIATES.tmp = data.matrix(COVARIATES[,c("Gender", "Dx.Tissue")])
COVARIATES.tmp[is.na(COVARIATES.tmp)] = 0

tmp = CQN.GENE_EXPRESSION$E
tmp[is.na(tmp)] = 0
tree = hclust(as.dist(t(tmp)))
cols = WGCNA::labels2colors(COVARIATES.tmp);

WGCNA::plotDendroAndColors(tree, 
                           colors = cols, 
                           dendroLabels = FALSE, 
                           abHeight = 0.80, 
                           main = "Sample dendrogram",
                           groupLabels = colnames(COVARIATES.tmp))
```
```{r temp, include = F}
dev.off()
gc()
```

### Distribution of samples (log cpm)
```{r lcpm.dist, cache=FALSE}
# Plot abberent distribution of logcpm counts
tmp1 = (CQN.GENE_EXPRESSION$E) %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  tidyr::gather(SampleID, logCPM, -ensembl_gene_id) %>%
  left_join(COVARIATES %>%
              rownameToFirstColumn('SampleID') %>%
              tidyr::separate(Dx.Tissue, c('Dx', 'Tissue'), sep = '_'))

p = ggplot(tmp1, aes(x = logCPM, color = SampleID)) + geom_density() 
p = p + theme(legend.position = 'NONE') + facet_grid(Dx+.~Tissue, scale = 'free')
p
```

### Significant Covariates
Correlation between pca of unadjusted mRNA expression and covariates is used to find significant covariates
```{r preAdjusted.covariates, cache=TRUE}
# Find correlation between PC's of gene expression with covariates
tmp = CQN.GENE_EXPRESSION$E
tmp[is.na(tmp)] = 0
preAdjustedSigCovars = runPCAandPlotCorrelations(tmp, 
                                                 COVARIATES,
                                                 'NULL design(voom-normalized)', 
                                                 isKeyPlot=TRUE, 
                                                 MIN_PVE_PCT_PC = 1)
```

Significant covariates to adjust at FDR 0.1 are `r preAdjustedSigCovars$significantCovars`
```{r preAdjustedSigCovars.NULL, fig.width=12, fig.height=8}
preAdjustedSigCovars[["PC_res"]][[2]]$plotData
```

### Custom Normalisation
Dx.Tissue is chosen as the primary variable of interest (i.e., covariate adjustments is conditioned on diagnosis and tissue).

Based on the model selection analysis here (syn9907541), following variables were controlled for differential expression: 
Gender, RIN, IntronicRate
```{r custom.normalisation, results='asis'}
adjust.covars = c('Dx.Tissue', 'Gender', 'RIN', 'IntronicRate')
writeLines(paste('Using following covariates in the model:',
                 paste(adjust.covars, collapse=', ')))

# Post adjusted design matrix
DM1 = getDesignMatrix(COVARIATES[,adjust.covars,drop=F],Intercept = F)
DM1$design = DM1$design[,linColumnFinder(DM1$design)$indepCols]

# Estimate voom weights
cnts = NEW.COUNTS; cnts[is.na(cnts)] = 0
VOOM.GENE_EXPRESSION = voom(cnts, design=DM1$design, plot=F)
VOOM.GENE_EXPRESSION$E = CQN.GENE_EXPRESSION$E

# Fit linear model using new weights and new design
ADJUSTED.FIT = lmFit(VOOM.GENE_EXPRESSION)

# Residuals after normalisation
RESIDUAL.GENE_EXPRESSION = residuals.MArrayLM(ADJUSTED.FIT, CQN.GENE_EXPRESSION$E)
```

### SVA Adjustments for eQTL analysis
Conditioned on primary variable (Dx.Tissue) and covariates estimate surrogate variables using SVA package
```{r sva}
# Get (null) design matrix
DESIGN = DM1$design
MODEL0 = DESIGN[,-grep('Dx.Tissue',colnames(DESIGN))] # Get null model by removing variable of interest
MODEL0 = MODEL0[,linColumnFinder(MODEL0)$indepCols]
MODEL1 = DESIGN
MODEL1 = MODEL1[,linColumnFinder(MODEL1)$indepCols]

# Compute actual variance of all principal components
expr = RESIDUAL.GENE_EXPRESSION; expr[is.na(expr)] = 0
tmp = svd(expr)
actual.var = tmp$d^2/sum(tmp$d^2)

# Compute permuted variance of all principal components
permuted.var = foreach(i = 1:20, .combine = rbind, .packages = c('dplyr')) %dopar% {
  tmp.residual = t(apply(expr, 1, sample, replace = FALSE))
  tmp = svd(tmp.residual)
  permuted.var = tmp$d^2/sum(tmp$d^2)
}
permuted.var = apply(permuted.var, 2, mean)
NUM.SV = sum(actual.var >= permuted.var[1])

# Plot variance components
var.comp = data.frame(component = 1:length(actual.var), 
                      residual = actual.var, 
                      permuted.residual = permuted.var) %>%
  tidyr::gather(data, value, -component)
p = ggplot(var.comp %>% 
             dplyr::filter(component <= round(NUM.SV*1.2)), 
           aes(x = component, y = value, color = data)) + geom_point()
p = p + geom_hline(yintercept=permuted.var[1], linetype = 'dashed') + xlab('Singular Dimension Index')
p = p + geom_vline(xintercept=NUM.SV, linetype = 'dashed') + ylab('Fraction of Variance Explained')
p = p + theme(legend.position = c(0.8, 0.8), legend.title = element_blank())
p

# Estimate surrogate variables
expr = CQN.GENE_EXPRESSION$E
expr[is.na(expr)] = 0
SURR.VAR = irwsva.build(expr, MODEL1, MODEL0, 
                        n.sv = NUM.SV, B = 30, tol = 1e-20)$sv
colnames(SURR.VAR) = paste0('SV',1:dim(SURR.VAR)[2])
rownames(SURR.VAR) = rownames(MODEL1)

# Estimate voom weights for dispersion control
VOOM.SVA.WEIGHTS = voom(cnts, 
                        design=cbind(MODEL1, SURR.VAR), plot=F)
VOOM.SVA.WEIGHTS$E = CQN.GENE_EXPRESSION$E

# Fit linear model using new weights and new design
VOOM.SVA.FIT = lmFit(VOOM.SVA.WEIGHTS)

# Residuals after normalisation
RESIDUAL.SVA.GENE_EXPRESSION = residuals.MArrayLM(VOOM.SVA.FIT,
                                                  CQN.GENE_EXPRESSION$E)
```

### Residual calculation
Calculate weighted residuals and add back "Dx.Tissue" to the residuals
```{r varsToAddBack}
# Add variable of interest back to the residuals
varsToAddIn = grep("Dx.Tissue", colnames(DESIGN), value = T)
RESIDUAL.SVA.GENE_EXPRESSION = RESIDUAL.SVA.GENE_EXPRESSION + 
  VOOM.SVA.FIT$coefficients[,varsToAddIn] %*% t(VOOM.SVA.FIT$design[,varsToAddIn])
```
Clustering residual data
```{r decompse.normalise.data2, fig.height=6, fig.width=6, results='asis'}
# Find principal components of expression to plot
expr = RESIDUAL.SVA.GENE_EXPRESSION; expr[is.na(expr)] = 0
PC <- prcomp(expr, scale.=T, center = T)

# Plot first 4 PCs
plotdata <- data.frame(SampleID=rownames(PC$rotation), 
                       PC1=PC$rotation[,1], 
                       PC2=PC$rotation[,2])

plotdata <- left_join(plotdata, rownameToFirstColumn(COVARIATES, 'SampleID')) %>%
  tidyr::separate(Dx.Tissue, c('Dx','Tissue'), sep = '_') %>%
  dplyr::mutate(label = SampleID)
# plotdata$label[!(plotdata$SampleID %in% top.nsamples)] = ''

p <- ggplot(plotdata, aes(x=PC1, y=PC2))
p <- p + geom_point(aes(color = Dx, shape=Tissue, size=Age_of_Death))
p <- p + theme_bw() + theme(legend.position="right") + facet_grid(Tissue~.)
# p <- p + geom_text(aes(label= label), size=4, hjust=0)
p
```

```{r decompse.normalise.data2.1, fig.height=8, fig.width=12, results='asis'}
# Eucledian tree based analysis
COVARIATES.tmp = data.matrix(COVARIATES[,c('Dx.Tissue'),drop=FALSE])
COVARIATES.tmp[is.na(COVARIATES.tmp)] = 0

tree = hclust(as.dist(t(expr)))
cols = WGCNA::labels2colors(COVARIATES.tmp);

WGCNA::plotDendroAndColors(tree, 
                           colors = cols, 
                           dendroLabels = FALSE, 
                           abHeight = 0.80, 
                           main = "Sample dendrogram",
                           groupLabels = colnames(COVARIATES.tmp[,c('Dx.Tissue'),drop=FALSE]))
```

### Store files in synapse
```{r synapse.store, include=FALSE, eval=TRUE, cache=FALSE}
# Set annotations
all.annotations = list(
  dataType = 'mRNA',
  dataSubType = 'geneExp',
  summaryLevel = 'gene',
  assay	 = 'RNAseq',
  
  tissueTypeAbrv	= 'DLPFC', 
  study = 'HBCC', 
  
  organism = 'HomoSapiens',
  consortium	= 'CMC',
  
  normalizationStatus	= TRUE,
  
  normalizationType	= 'SVA'
)

# Code
CODE <- Folder(name = "HBCC - DLPFC - STAR - FEATURE COUNTS - ENSEMBL v75 - CQN - SVA", parentId = parentId)
annotations(CODE) = all.annotations
CODE <- synStore(CODE)

# Store covariates
COVARIATES = rownameToFirstColumn(COVARIATES, 'SampleID')
write.table(COVARIATES, file = 'HBCC_DLPFC_Covariates.tsv', sep = '\t', row.names=F, quote=F)
COV_OBJ = File('HBCC_DLPFC_Covariates.tsv', name = 'Covariates', parentId = CODE$properties$id)
annotations(COV_OBJ) = annotations(CODE)
annotations(COV_OBJ)$dataSubType = 'covariates'
COV_OBJ = synStore(COV_OBJ, used = ALL_USED_IDs, activityName = activityName, 
                   executed = thisFile, activityDescription = activityDescription)

# Store filtered counts
PROCESSED_COUNTS$filteredExprMatrix$counts %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'HBCC_DLPFC_Counts.tsv', sep = '\t', row.names=F, quote=F)
COUNT_OBJ = File('HBCC_DLPFC_Counts.tsv', name = 'Counts (filtered raw)', parentId = CODE$properties$id)
annotations(COUNT_OBJ) = annotations(CODE)
annotations(COUNT_OBJ)$dataSubType = 'filteredCounts'
COUNT_OBJ = synStore(COUNT_OBJ, activity = synGetActivity(COV_OBJ$properties$id))

# Store filtered counts
NEW.COUNTS %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'HBCC_DLPFC_nCounts.tsv', sep = '\t', row.names=F, quote=F)
NCOUNT_OBJ = File('HBCC_DLPFC_nCounts.tsv', name = 'Counts (estimated)', parentId = CODE$properties$id)
annotations(NCOUNT_OBJ) = annotations(CODE)
annotations(NCOUNT_OBJ)$dataSubType = 'estimatedCounts'
NCOUNT_OBJ = synStore(NCOUNT_OBJ, activity = synGetActivity(COV_OBJ$properties$id))

# Store logCPM
CQN.GENE_EXPRESSION$E %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'HBCC_DLPFC_logCPM.tsv', sep = '\t', row.names=F, quote=F)
LCOUNT_OBJ = File('HBCC_DLPFC_logCPM.tsv', name = 'Counts (filtered logCPM)', parentId = CODE$properties$id)
annotations(LCOUNT_OBJ) = annotations(CODE)
annotations(LCOUNT_OBJ)$dataSubType = 'filteredLCPM'
LCOUNT_OBJ = synStore(LCOUNT_OBJ, activity = synGetActivity(COV_OBJ$properties$id))

# Store cqn offsets
CQN.GENE_EXPRESSION$offset %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'HBCC_DLPFC_offset.tsv', sep = '\t', row.names=F, quote=F)
OFFSET_OBJ = File('HBCC_DLPFC_offset.tsv', name = 'Gene length and GC content offset', parentId = CODE$properties$id)
annotations(OFFSET_OBJ) = annotations(CODE)
annotations(OFFSET_OBJ)$dataSubType = 'offset'
OFFSET_OBJ = synStore(OFFSET_OBJ, activity = synGetActivity(COV_OBJ$properties$id))

# Store design matrix
DM1$design %>%
  rownameToFirstColumn('SampleID') %>%
  write.table(file = 'HBCC_DLPFC_Design.tsv', sep = '\t', row.names=F, quote=F)
DM_OBJ = File('HBCC_DLPFC_Design.tsv', name = 'Design Matrix', parentId = CODE$properties$id)
annotations(DM_OBJ) = annotations(CODE)
annotations(DM_OBJ)$dataSubType = 'designMatrix'
DM_OBJ = synStore(DM_OBJ, activity = synGetActivity(COV_OBJ$properties$id))

# Store design matrix
SURR.VAR %>%
  rownameToFirstColumn('SampleID') %>%
  write.table(file = 'HBCC_DLPFC_SurrVar.tsv', sep = '\t', row.names=F, quote=F)
SURR.VAR_OBJ = File('HBCC_DLPFC_SurrVar.tsv', name = 'Surrogate Variables', parentId = CODE$properties$id)
annotations(SURR.VAR_OBJ) = annotations(CODE)
annotations(SURR.VAR_OBJ)$dataSubType = 'surrogateVariable'
SURR.VAR_OBJ = synStore(SURR.VAR_OBJ, activity = synGetActivity(COV_OBJ$properties$id))

# Store residual gene expression for network analysis
RESIDUAL.SVA.GENE_EXPRESSION %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'HBCC_DLPFC_eqtlResidualExpression.tsv', sep = '\t', row.names=F, quote=F)
eEXP_OBJ = File('HBCC_DLPFC_eqtlResidualExpression.tsv', 
                name = 'Normalised, covariates removed residual expression (for eQTL analysis)', 
                parentId = CODE$properties$id)
annotations(eEXP_OBJ) = annotations(CODE)
annotations(eEXP_OBJ)$dataSubType = 'residualGeneExpForNetAnlz'
eEXP_OBJ = synStore(eEXP_OBJ, activity = synGetActivity(COV_OBJ$properties$id))

# stopCluster(cl)
```
|  *Results*                                  |  *SynapseID*                     |
|  -----------------------------------------  |   ---------                      |
|  Covariates                                 |  `r COV_OBJ$properties$id`       |
|  Counts (raw)                               |  `r COUNT_OBJ$properties$id`     |
|  Counts (estimated)                         |  `r NCOUNT_OBJ$properties$id`    |
|  Counts (lcpm)                              |  `r LCOUNT_OBJ$properties$id`    |
|  Offset (for gene length and gc content)    |  `r OFFSET_OBJ$properties$id`    |
|  Design Matrix                              |  `r DM_OBJ$properties$id`        |
|  Surrogate Variables                        |  `r SURR.VAR_OBJ$properties$id`  |
|  Residual Expression (for eQTL analysis)    |  `r eEXP_OBJ$properties$id`      |

### Source Code
[R markdown](`r thisFile`)