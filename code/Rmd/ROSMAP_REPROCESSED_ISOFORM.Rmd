---
title: "Covariate analysis of ROSMAP reprocessed isfoform counts (with CQN normalisation and covariates adjusted)"
author: "Thanneer Perumal"
date: "`r date()`"
output: html_document
---
```{r knit2synapse, eval=FALSE}
library(synapseClient)
library(knit2synapse) # get the package from devtools::install_github('Sage-Bionetworks/knit2synapse')

synapseLogin()

knit2synapse::knitToFolderEntity(file = "./ROSMAP_REPROCESSED_ISOFORM.Rmd",
                                 parentId = "syn8672910",
                                 entityName = 'ROSMAP Reprocessed Isoform (Normalised)')
```

```{r libs, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}
## It is assumed your working directory is where this file

## Load required libraries
library(CovariateAnalysis) # get the package from devtools::install_github('th1vairam/CovariateAnalysis@dev')
library(data.table)
library(tidyr)
library(plyr)
library(dplyr)
library(stringr)

library(ggplot2)
library(reshape2)
library(limma)
library(gplots)
library(WGCNA)
library(psych)
library(edgeR)
library(biomaRt)
library(RColorBrewer)
library(cqn)

library(synapseClient)
library(knitr)
library(githubr) # get the package from devtools::install_github('brian-bot/githubr')
library(rSynapseUtilities)

synapseLogin()

library(doParallel)
library(foreach)

cl = makeCluster(detectCores()-2)
registerDoParallel(cl)

options(xtable.type="html")

knitr::opts_chunk$set(
  echo=FALSE,
  warning=FALSE,
  message=FALSE,
  error = FALSE,
  tidy = FALSE,
  cache = TRUE)
```

```{r synapse.parameters, include=FALSE, cache=TRUE}
# Synapse parameters
parentId = 'syn8672910';
activityName = 'Covariate analysis';
activityDescription = 'Covariate analysis of ROSMAP reprocessed isoform data';

thisFileName <- 'ROSMAP_REPROCESSED_ISOFORM.Rmd'

# Github link
thisRepo <- getRepo(repository = "th1vairam/Brain_Reg_Net", ref="branch", refName='AMPAD_isoform')
thisFile <- getPermlink(repository = thisRepo, repositoryPath=paste0('code/Rmd/',thisFileName))
```
### Data download
#### Obtain count matrix and metadata from synapse.
```{r download.data, cache=TRUE}
# Download expression data
COUNT_ID <- 'syn10507749';
ALL_USED_IDs <- COUNT_ID
COUNT_OBJ <- synGet(COUNT_ID)
COUNT <- read.table(COUNT_OBJ@filePath,header=T,sep='\t',check.names = F, row.names = 1)
COUNT[,grep('150_120419', colnames(COUNT))[2]] = NULL

# Get clinical metadata
METADATA.CLINICAL_ID <- 'syn3191087'
ALL_USED_IDs[length(ALL_USED_IDs)+1] = METADATA.CLINICAL_ID
METADATA.CLINICAL_OBJ <- synGet(METADATA.CLINICAL_ID)
METADATA.CLINICAL <- read.table(METADATA.CLINICAL_OBJ@filePath,sep=',',header=T)

METADATA.CLINICAL_ID1 <- 'syn7116000'
ALL_USED_IDs[length(ALL_USED_IDs)+1] = METADATA.CLINICAL_ID1
METADATA.CLINICAL_OBJ1 <- synGet(METADATA.CLINICAL_ID1)
METADATA.CLINICAL1 <- read.table(METADATA.CLINICAL_OBJ1@filePath,sep=',',header=T)

# Get technical covariates
METADATA.TECH_ID <- 'syn4300313'
ALL_USED_IDs[length(ALL_USED_IDs)+1] = METADATA.TECH_ID
METADATA.TECH_OBJ <- synGet(METADATA.TECH_ID)
METADATA.TECH <- read.table(METADATA.TECH_OBJ@filePath,sep='\t',header=T)

# Fix error in technical covariates data
KEY_ID <- 'syn3382527'
ALL_USED_IDs[length(ALL_USED_IDs)+1] = KEY_ID  
KEY <- read.csv(synGet(KEY_ID)@filePath) %>% 
  filter(mrna_data == 1) %>%
  dplyr::select(projid, mrna_id) %>%
  separate(mrna_id, c('a','b','batch'), sep = '_') %>% 
  unite(Sampleid, a, b) %>%
  dplyr::select(-batch) %>%
  unique

# Match technical and clinical covariates
METADATA <- METADATA.TECH %>%
  dplyr::select(-projid) %>%
  dplyr::left_join(KEY) %>%
  dplyr::left_join(METADATA.CLINICAL) %>%
  dplyr::select(-age_first_ad_dx, -age_death, -age_at_visit_max) %>%
  dplyr::left_join(METADATA.CLINICAL1)

# Pick higher quality RIN batch for sample 492_120515
METADATA <- METADATA %>%
  group_by(Sampleid) %>%
  top_n(1, RINcontinuous)
```

### Data preprocessing
```{r preprocess.data,cache=TRUE, echo=TRUE}
# Remove samples with no cogdx, RIN, PMI scores and age_death
METADATA <- METADATA %>%
  ungroup %>%
  dplyr::filter(Sampleid %in% colnames(COUNT)) %>%
  dplyr::filter(!is.na(cogdx), !is.na(braaksc), !is.na(ceradsc)) %>%
  dplyr::filter(!is.na(RINcontinuous)) %>%
  dplyr::filter(!is.na(pmi)) %>%
  dplyr::filter(!is.na(age_death)) %>%
  as.data.frame()

METADATA$Diagnosis = 'OTHER'
METADATA$Diagnosis[METADATA$cogdx == 1 & METADATA$braaksc <= 3 & METADATA$ceradsc >= 3] = 'CONTROL'
METADATA$Diagnosis[METADATA$cogdx == 4 & METADATA$braaksc >= 4 & METADATA$ceradsc <= 2] = 'AD'
```

```{r preprocess.data1,cache=TRUE}
# Match covariates to expression data
indToRetain = intersect(METADATA$Sampleid, colnames(COUNT))
removedIDs = setdiff(colnames(COUNT), METADATA$Sampleid)

COUNT = COUNT[,indToRetain]

rownames(METADATA) = METADATA$Sampleid
METADATA = METADATA[indToRetain,]
```
Dorsolateral prefrontal cortex of `r dim(COUNT)[2]` subjects from the ROS and MAP cohorts are used for the analysis. Following sample are removed `r paste(removedIDs, collapse = ',')`

### Covariate clustering
Determine relationship between covariates
```{r covariates.clustering, cache=TRUE}
primaryVariable <- c("cogdx", "Diagnosis", "apoe_genotype")
FactorCovariates <- c("Batch", "msex", "race", "spanish", "cogdx", 
                      "Diagnosis", "apoe_genotype")
ContCovariates <- c("RINcontinuous", "age_death", "pmi", "educ")
  
# Find inter relation between factor covariates
COVARIATES = METADATA[,c(FactorCovariates,ContCovariates),drop=F]
COVARIATES <- data.frame(lapply(COVARIATES,function(x){x <- sapply(x,function(y){str_replace_all(as.character(y),'\\+','')})}))
rownames(COVARIATES) <- METADATA$Sampleid

# Convert factor covariates to factors
COVARIATES[,FactorCovariates] = lapply(COVARIATES[,FactorCovariates], factor)
COVARIATES[,ContCovariates] = lapply(COVARIATES[,ContCovariates], as.character)
COVARIATES[,ContCovariates] = lapply(COVARIATES[,ContCovariates], as.numeric)

# Add in RIN^2 values
COVARIATES$RINcontinuous2 = COVARIATES$RINcontinuous^2
ContCovariates = c(ContCovariates, 'RINcontinuous2')

levels(COVARIATES$apoe_genotype) = c('ApoE0','ApoE0','ApoE1',
                                     'ApoE0','ApoE1','ApoE2')
```
Correlation/association between covariates at an FDR <= 0.1
```{r covariates.correlation, fig.width=9, fig.height=6}
COVARIATES.CORRELATION = getAssociationStatistics(COVARIATES, PVAL = 0.05)
draw(COVARIATES.CORRELATION$plot, heatmap_legend_side = 'left', 
     padding  = unit(c(18,2,2,18), 'mm'))
```
### Explore metadata
```{r data.explore, fig.width = 10, fig.height = 14}
# RIN
p = list()
p[[1]] = ggplot(COVARIATES, aes(x = Diagnosis, y = RINcontinuous)) + geom_boxplot()
p[[1]] = p[[1]] + ggtitle('RIN') + theme(legend.position = 'top')

# AgeAtDeath
p[[2]] = ggplot(COVARIATES, aes(x = Diagnosis, y = age_death)) + geom_boxplot()
p[[2]] = p[[2]] + ggtitle('AgeOfDeath') + theme(legend.position = 'top')

# PMI
p[[3]] = ggplot(COVARIATES, aes(x = Diagnosis, y = pmi)) + geom_boxplot()
p[[3]] = p[[3]] + ggtitle('PMI') + theme(legend.position = 'top')

# Education
p[[4]] = ggplot(COVARIATES, aes(x = Diagnosis, y = educ)) + geom_boxplot()
p[[4]] = p[[4]] + ggtitle('Education') + theme(legend.position = 'top')

multiplot(plotlist = p, cols = 2)

# Batch
# vcd::mosaic(~ Batch + Diagnosis, data = COVARIATES)

# Sex
# vcd::mosaic(~ msex + Diagnosis, data = COVARIATES)
```
### Filter Transcripts
Remove transcripts that have less than 5 tpm in at least 50% of samples per Diagnosis
```{r cpmnormalisation}
genesToAnalyze = COVARIATES %>%
  rownameToFirstColumn('Sampleid') %>%
  dlply(.(Diagnosis), .fun = function(mtd, count){
  processed.counts = getGeneFilteredGeneExprMatrix(count[,mtd$Sampleid],
                                                   MIN_GENE_CPM=5, 
                                                   MIN_SAMPLE_PERCENT_WITH_MIN_GENE_CPM=0.5)
  processed.counts$filteredExprMatrix$genes
}, COUNT)

genesToAnalyze = unlist(genesToAnalyze) %>% 
  unique() %>%
  setdiff(c("N_unmapped", "N_multimapping", "N_noFeature", "N_ambiguous"))

PROCESSED_COUNTS = getGeneFilteredGeneExprMatrix(COUNT[genesToAnalyze, ], 
                                                 MIN_GENE_CPM=0, 
                                                 MIN_SAMPLE_PERCENT_WITH_MIN_GENE_CPM=0)
```
Processing `r dim(PROCESSED_COUNTS$filteredExprMatrix)[1]` genes in `r dim(PROCESSED_COUNTS$filteredExprMatrix)[2]` samples

### Outlier Analysis
```{r outlier.analysis, cache = FALSE, fig.width = 10}
indToRemove = c('380_120503', '500_120515')

# Find principal components of expression to plot
PC <- prcomp(voom(PROCESSED_COUNTS$filteredExprMatrix$counts)$E, scale.=T, center = T)

# Plot first 2 PCs
plotdata <- data.frame(SampleID=rownames(PC$rotation), 
                       PC1=PC$rotation[,1], 
                       PC2=PC$rotation[,2])

plotdata <- left_join(plotdata, rownameToFirstColumn(COVARIATES, 'SampleID')) %>%
  dplyr::mutate(label = SampleID)
plotdata$label[!(plotdata$SampleID %in% indToRemove)] = ''

p <- ggplot(plotdata, aes(x=PC1, y=PC2))
p <- p + geom_point(aes(color=Batch, shape=Diagnosis, size=RINcontinuous))
p <- p + theme_bw() + theme(legend.position="right")
p <- p + geom_text(aes(label= label), size=4, hjust=0)
p

# Plot abberent distribution of logcpm counts
tmp1 = voom(PROCESSED_COUNTS$filteredExprMatrix$counts)$E %>%
  rownameToFirstColumn('Tx.ID') %>%
  tidyr::gather(SampleID, logCPM, -Tx.ID) %>%
  left_join(COVARIATES %>%
              rownameToFirstColumn('SampleID'))

p = ggplot(tmp1 %>%
             dplyr::filter(SampleID %in% indToRemove),
           aes(x = logCPM, color = SampleID)) + geom_density() 
p = p + theme(legend.position = 'top')
p

indToRetain = setdiff(colnames(PROCESSED_COUNTS$filteredExprMatrix$counts), indToRemove)
PROCESSED_COUNTS$filteredExprMatrix$counts = PROCESSED_COUNTS$filteredExprMatrix$counts[,indToRetain]
COVARIATES = COVARIATES[indToRetain,]

tmp = COVARIATES %>%
  dplyr::group_by(Diagnosis, cogdx) %>%
  dplyr::summarise(count = n()) %>%
  tidyr::spread(Diagnosis, count)
```
Processing `r dim(PROCESSED_COUNTS$filteredExprMatrix)[1]` genes in `r dim(PROCESSED_COUNTS$filteredExprMatrix)[2]` samples

Based on the expression pattern following samples were tagged as outliers: `r paste(indToRemove, collapse = ', ')`

Distribution of samples are: `r kable(tmp)`

### Winsorise counts (Gene outliers in samples)
```{r winsorise.data}
LOG.CPM = cpm(PROCESSED_COUNTS$filteredExprMatrix$counts, log = T)

# Set gene counts in specific samples that are deviating 3 sd from other samples to 3SD limit
LOG.CPM = apply(LOG.CPM, 1, function(x){
  mn = mean(x, na.rm = T)
  std.dev = sd(x, na.rm = T)
  
  ind.low = which(x == max(x[which(x <= mn-3*std.dev)], na.rm = T))
  ind.high = which(x == min(x[which(x >= mn+3*std.dev)], na.rm = T))
  
  x[x < (mn-3*std.dev)] = x[ind.low]
  x[x > (mn+3*std.dev)] = x[ind.high]
  return(x)
}) %>% t

# Back calculate counts for further analysis
LIB.SIZE = colSums(PROCESSED_COUNTS$filteredExprMatrix$counts)
NEW.COUNTS = (2^LOG.CPM) * t(replicate(dim(LOG.CPM)[1], LIB.SIZE))/1e6
```

### Library Normalisation (TMM)
```{r tmm}
# Compute calc norm factors
TMM.GENE_EXPRESSION = calcNormFactors(NEW.COUNTS, lib.size = LIB.SIZE, method = 'TMM')
VOOM.GENE_EXPRESSION = voom(NEW.COUNTS, design = NULL, 
                            lib.size = TMM.GENE_EXPRESSION*LIB.SIZE)

# Set gene counts in specific samples that are deviating 3 sd from other samples to 3SD limit
LOG.CPM = apply(VOOM.GENE_EXPRESSION$E, 1, function(x){
  mn = mean(x, na.rm = T)
  std.dev = sd(x, na.rm = T)
  
  ind.low = which(x == max(x[which(x <= mn-3*std.dev)], na.rm = T))
  ind.high = which(x == min(x[which(x >= mn+3*std.dev)], na.rm = T))
  
  x[x < (mn-3*std.dev)] = x[ind.low]
  x[x > (mn+3*std.dev)] = x[ind.high]
  return(x)
}) %>% t
VOOM.GENE_EXPRESSION$E = LOG.CPM
NEW.COUNTS = (2^LOG.CPM) * t(replicate(dim(LOG.CPM)[1], TMM.GENE_EXPRESSION * LIB.SIZE))/1e6
```

### Sample clustering
```{r decompse.normalise.data, fig.height=8, fig.width=8, results='asis', cache=FALSE}
# Find principal components of expression to plot
PC <- prcomp(VOOM.GENE_EXPRESSION$E, scale.=T, center = T)

# Plot first 2 PCs
plotdata <- data.frame(SampleID=rownames(PC$rotation), 
                       PC1=PC$rotation[,1], 
                       PC2=PC$rotation[,2])

plotdata <- left_join(plotdata, rownameToFirstColumn(COVARIATES, 'SampleID'))

p <- ggplot(plotdata, aes(x=PC1, y=PC2))
p <- p + geom_point(aes(color=Batch, shape=cogdx, size=RINcontinuous))
p <- p + theme_bw() + theme(legend.position="right")
p
```
Tree based clustering of samples
```{r decompse.normalise.data.1, fig.height=6, fig.width=10, results='asis'}
# Eucledian tree based analysis
COVARIATES.tmp = data.matrix(COVARIATES[,c("Batch", "msex", "Diagnosis")])
COVARIATES.tmp[is.na(COVARIATES.tmp)] = 0

tree = hclust(as.dist(t(VOOM.GENE_EXPRESSION$E)))
cols = WGCNA::labels2colors(COVARIATES.tmp);

WGCNA::plotDendroAndColors(tree, 
                           colors = cols, 
                           dendroLabels = FALSE, 
                           abHeight = 0.80, 
                           main = "Sample dendrogram",
                           groupLabels = colnames(COVARIATES.tmp))
```
```{r temp, include = F}
dev.off()
gc()
```

### Distribution of samples (log cpm)
```{r lcpm.dist, cache=FALSE, fig.height=10, fig.width=20}
# Plot abberent distribution of logcpm counts
tmp1 = (VOOM.GENE_EXPRESSION$E) %>%
  rownameToFirstColumn('Tx.ID') %>%
  tidyr::gather(SampleID, logCPM, -Tx.ID) %>%
  left_join(COVARIATES %>%
              rownameToFirstColumn('SampleID'))

p = ggplot(tmp1, aes(x = logCPM, color = SampleID)) + geom_density() 
p = p + theme(legend.position = 'NONE') + facet_grid(.~Diagnosis, scale = 'free')
p
```

Coexpression of genes 
```{r coexp1, cache=FALSE, fig.height=5, fig.width=5}
cr = cor(t(VOOM.GENE_EXPRESSION$E))
hist(cr, main = 'Distribution of correlation between genes', xlab = 'Correlation')
```

### Significant Covariates
Correlation between pca of unadjusted mRNA expression and covariates are used to find significant covariates
```{r preadj.covariates, cache=TRUE}
# Find correlation between PC's of gene expression with covariates
preAdjustedSigCovars = runPCAandPlotCorrelations(VOOM.GENE_EXPRESSION$E, 
                                                 COVARIATES,
                                                 'NULL design(voom-normalized)', 
                                                 isKeyPlot=TRUE, 
                                                 MIN_PVE_PCT_PC = 1)
```

Significant covariates to adjust at FDR 0.1 are `r preAdjustedSigCovars$significantCovars`
```{r preadj.covariates.plot, fig.width=12, fig.height=8}
preAdjustedSigCovars[["PC_res"]][[2]]$plotData
```
### Normalisation (iterative design)
Since many covariates are correlated, re-normalising and re-adjusting COUNTS with an iterative design matrix.
1. Adding Batch and msex a priori to variable selection
2. Primary variable of interest Diagnosis is excluded from the pool of available covariates for selection
```{r iterative.norm, results='asis'}
# Primary variable of interest
postAdjustCovars = c('Batch', 'msex');

# Assign residual covariates
residualCovars = setdiff(preAdjustedSigCovars$significantCovars, c(postAdjustCovars, primaryVariable))
residualSigCovars = preAdjustedSigCovars
covariatesEffects = preAdjustedSigCovars$Effects.significantCovars[residualCovars]
postAdjustCovars = c(postAdjustCovars, names(which.max(covariatesEffects))) %>% unique()

loopCount = 0 
while(length(residualSigCovars$significantCovars)!=0 && loopCount <= 20){
  writeLines(paste('Using following covariates in the model:',
                   paste(postAdjustCovars, collapse=', '),
                   'as fixed effects'))

  # Post adjusted design matrix
  DM1 = getDesignMatrix(COVARIATES[,postAdjustCovars,drop=F],Intercept = F)
  DM1$design = DM1$design[,linColumnFinder(DM1$design)$indepCols]

  # Estimate voom weights for dispersion control
  VOOM.GENE_EXPRESSION = voom(NEW.COUNTS, 
                              design=DM1$design, 
                              plot=F,
                              na.rm = T,
                              lib.size = TMM.GENE_EXPRESSION * LIB.SIZE)

  # Fit linear model using new weights and new design
  VOOM.ADJUSTED.FIT = lmFit(VOOM.GENE_EXPRESSION$E,
                            design = DM1$design,
                            weights = VOOM.GENE_EXPRESSION$weights)

  # Residuals after normalisation
  RESIDUAL.GENE_EXPRESSION = residuals.MArrayLM(VOOM.ADJUSTED.FIT,
                                                VOOM.GENE_EXPRESSION$E)
  
  # Residual covariates to choose from
  residCovars <- setdiff(c(FactorCovariates,ContCovariates), c(postAdjustCovars, primaryVariable))

  # Find PC of residual gene expression and significant covariates that are highly correlated with PCs
  residualSigCovars = runPCAandPlotCorrelations(RESIDUAL.GENE_EXPRESSION, 
                                                COVARIATES[, residCovars, drop=F], 
                                                'adjusted design(voom-normalized)',
                                                isKeyPlot=TRUE)

  # Add postadjusted covariates (if any)
  residCovars = setdiff(residualSigCovars$significantCovars, c(postAdjustCovars, primaryVariable))
  covariatesEffects = residualSigCovars$Effects.significantCovars[residCovars]

  postAdjustCovars = c(postAdjustCovars, names(which.max(covariatesEffects)))
  loopCount = loopCount + 1
}

modelStr <- paste(paste(gsub('_','\\\\_',postAdjustCovars), collapse=', '),
                  'as fixed effects')

tmp <- paste('Using following covariates in the final model:', modelStr)
```

### Sanity check
```{r residual.adj, fig.width=12, fig.height=8}
# Find PC of residual gene expression and significant covariates that are highly correlated with PCs
residualSigCovars = runPCAandPlotCorrelations(RESIDUAL.GENE_EXPRESSION, 
                                              COVARIATES,
                                              'adjusted design(voom-normalized)',
                                              isKeyPlot=TRUE)

residualSigCovars[["PC_res"]][[2]]$plotData
```
Coexpression of genes 
```{r coexp2, cache=FALSE, fig.height=5, fig.width=5}
cr = cor(t(RESIDUAL.GENE_EXPRESSION))
hist(cr, main = 'Distribution of correlation between genes', xlab = 'Correlation')
```

### Clustering residual data
```{r decompse.normalise.data2.1, fig.height=6, fig.width=8, results='asis'}
# Find principal components of expression to plot
PC <- prcomp(RESIDUAL.GENE_EXPRESSION, scale.=T, center = T)

# Plot first 4 PCs
plotdata <- data.frame(SampleID=rownames(PC$rotation), 
                       PC1=PC$rotation[,1], 
                       PC2=PC$rotation[,2])

plotdata <- left_join(plotdata, rownameToFirstColumn(COVARIATES, 'SampleID'))

p <- ggplot(plotdata, aes(x=PC1, y=PC2)) 
p <- p + geom_point(aes(color=Batch, shape=Diagnosis, size=RINcontinuous))
p <- p + theme_bw() + theme(legend.position="right")
# p <- p + geom_text(aes(label= SampleID), size=4, hjust=1)
p
```

```{r decompse.normalise.data2.2, fig.height=8, fig.width=12, results='asis'}
# Eucledian tree based analysis
COVARIATES.tmp = data.matrix(COVARIATES[,c('Batch', 'msex', primaryVariable)])
COVARIATES.tmp[is.na(COVARIATES.tmp)] = 0

tree = hclust(as.dist(t(RESIDUAL.GENE_EXPRESSION)))
cols = WGCNA::labels2colors(COVARIATES.tmp);

WGCNA::plotDendroAndColors(tree, 
                           colors = cols, 
                           dendroLabels = FALSE, 
                           abHeight = 0.80, 
                           main = "Sample dendrogram",
                           groupLabels = colnames(COVARIATES.tmp))
```

```{r temp1, include=F}
dev.off()
gc()
```

### Differential expression analysis (with cogdx as primary variable)
Differential expression is performed on the primary variable by controlling for covariates identified above

Interpretation of cogdx scores
1. NCI, No cognitive impairment (No impaired domains)
2. MCI, Mild cognitive impairment (One impaired domain) and NO other cause of CI
3. MCI, Mild cognitive impairment (One impaired domain) AND another cause of CI
4. AD, Alzheimer's disease and NO other cause of CI (NINCDS PROB AD)
5. AD, Alzheimer's disease AND another cause of CI (NINCDS POSS AD)
6. Other dementia. Other primary cause of dementia

Genes that are differentially expressed at an FDR <= 0.05 are
```{r diff.exp, fig.height=6, fig.width=18, cache=FALSE}
# Get design matrix
DESIGN = getDesignMatrix(COVARIATES[, c(primaryVariable[1], postAdjustCovars), drop = F], Intercept = F)
DESIGN$design = DESIGN$design[,linColumnFinder(DESIGN$design)$indepCols]

# Estimate voom weights for dispersion control
VOOM.WEIGHTS = voom(NEW.COUNTS, design=DESIGN$design, plot=F, lib.size = TMM.GENE_EXPRESSION * LIB.SIZE)

# Fit linear model using new weights and new design
FIT = lmFit(VOOM.WEIGHTS$E,
            design = DESIGN$design,
            weights = VOOM.WEIGHTS$weights)
  
# Fit contrast
contrast = makeContrasts(contrasts=c("cogdx2-cogdx1",
                                     "cogdx4-cogdx1",
                                     "cogdx4-cogdx2"),
                         levels = colnames(FIT$coefficients))
FIT.CONTR = contrasts.fit(FIT, contrasts=contrast)
FIT.CONTR = eBayes(FIT.CONTR)

# Get differnetial expression
DE = lapply(1:3, function(i, FIT){
  topTable(FIT, coef=i, number = 50000, confint = T) %>%
    rownameToFirstColumn('Tx.ID')
}, FIT.CONTR)
names(DE) = colnames(contrast)

DE = DE %>% 
  rbindlist(idcol = 'Comparison') %>%
  dplyr::mutate(Study = 'ROSMAP', Region = 'DLPFC',
                Direction = logFC/abs(logFC),
                Direction = factor(Direction, c(-1,1), c('-1' = 'DOWN', '1' = 'UP')),
                Direction = as.character(Direction))
DE$Direction[DE$adj.P.Val > 0.05 | abs(DE$logFC) < log2(1.2)] = 'NONE'

writeLines('Differentially expressed genes at an FDR 0.05 and logFC 1.2')
tmp = DE %>%
  dplyr::select(Tx.ID, Comparison, Direction) %>%
  group_by(Comparison, Direction) %>%
  dplyr::summarise(FDR_0_05_FC_1.2 = length(unique(Tx.ID))) %>%
  spread(Direction, FDR_0_05_FC_1.2) 
kable(tmp)

p = ggplot(DE, aes(y = -log10(adj.P.Val), x = logFC, color = Direction)) + geom_point() + xlim(c(-1,1))
p = p + scale_color_manual(values = c('green','grey','red'))
p = p + facet_grid(.~Comparison, scales = 'fixed')
p

all.diff.exp = list(cogdx = DE)
all.fit = list(cogdx = FIT)
```

### Differential expression analysis (with Diagnosis as primary variable)
Differential expression is performed on the primary variable by controlling for covariates identified above

Interpretation of Diagnosis
1. AD: cogdx = 4, braaksc >= 4 and ceradsc <= 2
2. CONTROL: cogdx = 1, braaksc <= 3 and ceradsc >= 3
3. OTHER: All the other samples

Genes that are differentially expressed at an FDR <= 0.05 and folde change of 1.2 are
```{r diff.exp1, fig.height=6, fig.width=18, cache=FALSE}
# Get design matrix
DESIGN = getDesignMatrix(COVARIATES[, c(primaryVariable[2], postAdjustCovars), drop = F], Intercept = F)
DESIGN$design = DESIGN$design[,linColumnFinder(DESIGN$design)$indepCols]

# Estimate voom weights for dispersion control
VOOM.WEIGHTS = voom(NEW.COUNTS, design=DESIGN$design, plot=F, lib.size = TMM.GENE_EXPRESSION * LIB.SIZE)

# Fit linear model using new weights and new design
FIT = lmFit(VOOM.WEIGHTS$E,
            design = DESIGN$design,
            weights = VOOM.WEIGHTS$weights)
  
# Fit contrast
contrast = makeContrasts(contrasts=c("DiagnosisAD-DiagnosisCONTROL",
                                     "msex0"),
                         levels = colnames(FIT$coefficients))
FIT.CONTR = contrasts.fit(FIT, contrasts=contrast)
FIT.CONTR = eBayes(FIT.CONTR)

# Get differnetial expression
DE = lapply(1:dim(contrast)[2], function(i, FIT){
  topTable(FIT, coef=i, number = 50000, confint = T) %>%
    rownameToFirstColumn('Tx.ID')
}, FIT.CONTR)
names(DE) = c('AD-CONTROL','MALE-FEMALE')

DE = DE %>% 
  rbindlist(idcol = 'Comparison') %>%
  dplyr::mutate(Study = 'ROSMAP', Region = 'DLPFC',
                Direction = logFC/abs(logFC),
                Direction = factor(Direction, c(-1,1), c('-1' = 'DOWN', '1' = 'UP')),
                Direction = as.character(Direction))
DE$Direction[DE$adj.P.Val > 0.05 | abs(DE$logFC) < log2(1.2)] = 'NONE'

writeLines('Differentially expressed genes at an FDR 0.05 and logFC 1.2')
tmp = DE %>%
  dplyr::select(Tx.ID, Comparison, Direction) %>%
  group_by(Comparison, Direction) %>%
  dplyr::summarise(FDR_0_05_FC_1.2 = length(unique(Tx.ID))) %>%
  spread(Direction, FDR_0_05_FC_1.2) 
kable(tmp)

p = ggplot(DE, aes(y = -log10(adj.P.Val), x = logFC, color = Direction)) + geom_point() + xlim(c(-1,1))
p = p + scale_color_manual(values = c('green','grey','red'))
p = p + facet_grid(.~Comparison, scales = 'fixed')
p

all.diff.exp = c(all.diff.exp, list(Diagnosis = DE))
all.fit = c(all.fit, list(Diagnosis = FIT))
```

### Differential expression analysis (with APOE status as primary variable)
Differential expression is performed on the primary variable by controlling for covariates identified above

Interpretation of apoe_genotype
1. 0: No apoe4 allele
2. 1: 1 apoe4 allele
3. 2: 2 apoe4 allele

Genes that are differentially expressed at an FDR <= 0.05 and folde change of 1.2 are
```{r diff.exp2, fig.height=6, fig.width=18, cache=FALSE}
# Get design matrix
DESIGN = getDesignMatrix(COVARIATES[, c(primaryVariable[3], postAdjustCovars), drop = F], Intercept = F)
DESIGN$design = DESIGN$design[,linColumnFinder(DESIGN$design)$indepCols]
DESIGN$design = na.omit(DESIGN$design)

# Estimate voom weights for dispersion control
VOOM.WEIGHTS = voom(NEW.COUNTS[,rownames(DESIGN$design)], design=DESIGN$design, plot=F, 
                    lib.size = TMM.GENE_EXPRESSION * LIB.SIZE)

# Fit linear model using new weights and new design
FIT = lmFit(VOOM.WEIGHTS$E[,rownames(DESIGN$design)],
            design = DESIGN$design,
            weights = VOOM.WEIGHTS$weights)
  
# Fit contrast
contrast = makeContrasts(contrasts=c("apoe_genotypeApoE2-apoe_genotypeApoE0",
                                     "apoe_genotypeApoE2-apoe_genotypeApoE1",
                                     "apoe_genotypeApoE1-apoe_genotypeApoE0"),
                         levels = colnames(FIT$coefficients))
FIT.CONTR = contrasts.fit(FIT, contrasts=contrast)
FIT.CONTR = eBayes(FIT.CONTR)

# Get differnetial expression
DE = lapply(1:dim(contrast)[2], function(i, FIT){
  topTable(FIT, coef=i, number = 50000, confint = T) %>%
    rownameToFirstColumn('Tx.ID')
}, FIT.CONTR)
names(DE) = colnames(contrast)

DE = DE %>% 
  rbindlist(idcol = 'Comparison') %>%
  dplyr::mutate(Study = 'ROSMAP', Region = 'DLPFC',
                Direction = logFC/abs(logFC),
                Direction = factor(Direction, c(-1,1), c('-1' = 'DOWN', '1' = 'UP')),
                Direction = as.character(Direction))
DE$Direction[DE$adj.P.Val > 0.05 | abs(DE$logFC) < log2(1.2)] = 'NONE'

writeLines('Differentially expressed genes at an FDR 0.05 and logFC 1.2')
tmp = DE %>%
  dplyr::select(Tx.ID, Comparison, Direction) %>%
  group_by(Comparison, Direction) %>%
  dplyr::summarise(FDR_0_05_FC_1.2 = length(unique(Tx.ID))) %>%
  spread(Direction, FDR_0_05_FC_1.2) 
kable(tmp)

p = ggplot(DE, aes(y = -log10(adj.P.Val), x = logFC, color = Direction)) + geom_point() + xlim(c(-1,1))
p = p + scale_color_manual(values = c('green','grey','red'))
p = p + facet_grid(.~Comparison, scales = 'fixed')
p

all.diff.exp = c(all.diff.exp, list(Apoe = DE))
all.fit = c(all.fit, list(Apoe = FIT))
```

### Differential expression analysis (with Diagnosis and Gender)
Differential expression is performed on the Diagnosis x Gender variable by controlling for covariates identified above

Genes that are differentially expressed at an FDR <= 0.05 and folde change of 1.2 are
```{r diff.exp3, fig.height=6, fig.width=18, cache=FALSE}
## Modeling Diagnosis, msex and age_death conjointly
COVARIATES$Diagnosis.msex = paste(COVARIATES$Diagnosis, 
                                  factor(COVARIATES$msex, labels = c('0' = 'FEMALE', '1' = 'MALE')), sep = '.') %>%
  factor

# Get design matrix
DESIGN = getDesignMatrix(COVARIATES[, c('Diagnosis.msex', setdiff(postAdjustCovars, 'msex')), drop = F], Intercept = F)
DESIGN$design = DESIGN$design[,linColumnFinder(DESIGN$design)$indepCols]
colnames(DESIGN$design) = gsub('Diagnosis.msex','',colnames(DESIGN$design))

# Estimate voom weights for dispersion control
VOOM.WEIGHTS = voom(NEW.COUNTS, design=DESIGN$design, plot=F, lib.size = TMM.GENE_EXPRESSION * LIB.SIZE)

# Fit linear model using new weights and new design
FIT = lmFit(VOOM.WEIGHTS$E,
            design = DESIGN$design,
            weights = VOOM.WEIGHTS$weights)
  
# Fit contrast
contrast = makeContrasts(contrasts=c("(AD.FEMALE+AD.MALE)/2-(CONTROL.FEMALE+CONTROL.MALE)/2",
                                     "(AD.FEMALE+CONTROL.FEMALE)/2-(AD.MALE+CONTROL.MALE)/2",
                                     "(AD.FEMALE-CONTROL.FEMALE)/2-(AD.MALE-CONTROL.MALE)/2",
                                     "AD.FEMALE-CONTROL.FEMALE",
                                     "AD.MALE-CONTROL.MALE"),
                         levels = colnames(FIT$coefficients))
FIT.CONTR = contrasts.fit(FIT, contrasts=contrast)
FIT.CONTR = eBayes(FIT.CONTR)

# Get differnetial expression
DE = lapply(1:dim(contrast)[2], function(i, FIT){
  topTable(FIT, coef=i, number = 50000, confint = T) %>%
    rownameToFirstColumn('Tx.ID')
}, FIT.CONTR)
names(DE) = c('AD-CONTROL','FEMALE-MALE','AD-CONTROL.IN.FEMALE-MALE','AD-CONTROL.IN.FEMALE', 'AD-CONTROL.IN.MALE')

DE = DE %>% 
  rbindlist(idcol = 'Comparison') %>%
  dplyr::mutate(Study = 'ROSMAP', Region = 'DLPFC',
                Direction = logFC/abs(logFC),
                Direction = factor(Direction, c(-1,1), c('-1' = 'DOWN', '1' = 'UP')),
                Direction = as.character(Direction))
DE$Direction[DE$adj.P.Val > 0.05 | abs(DE$logFC) < log2(1.2)] = 'NONE'

writeLines('Differentially expressed genes at an FDR 0.05 and logFC 1.2')
tmp = DE %>%
  dplyr::select(Tx.ID, Comparison, Direction) %>%
  group_by(Comparison, Direction) %>%
  dplyr::summarise(FDR_0_05_FC_1.2 = length(unique(Tx.ID))) %>%
  spread(Direction, FDR_0_05_FC_1.2) 
kable(tmp)

p = ggplot(DE, aes(y = -log10(adj.P.Val), x = logFC, color = Direction)) + geom_point() + xlim(c(-1,1))
p = p + scale_color_manual(values = c('green','grey','red'))
p = p + facet_grid(.~Comparison, scales = 'fixed')
p

all.diff.exp = c(all.diff.exp, list(Diagnosis.Gender = DE))
all.fit = c(all.fit, list(Diagnosis.Gender = FIT))
```

### Differential expression analysis (with Diagnosis and AOD)
Differential expression is performed on the Diagnosis x AOD variable by controlling for covariates identified above

Genes that are differentially expressed at an FDR <= 0.05 and folde change of 1.2 are
```{r diff.exp4, fig.height=6, fig.width=18, cache=FALSE}
# Get design matrix
DESIGN = getDesignMatrix(COVARIATES[, c('Diagnosis', setdiff(postAdjustCovars, 'age_death')), drop = F], Intercept = F)
ind = grep('Diagnosis', colnames(DESIGN$design))
DESIGN$design[,ind] = DESIGN$design[,ind] * COVARIATES[rownames(DESIGN$design),'age_death']
DESIGN$design = DESIGN$design[,linColumnFinder(DESIGN$design)$indepCols]
colnames(DESIGN$design) = gsub('Diagnosis','AOD.',colnames(DESIGN$design))

# Estimate voom weights for dispersion control
VOOM.WEIGHTS = voom(NEW.COUNTS, design=DESIGN$design, plot=F, lib.size = TMM.GENE_EXPRESSION * LIB.SIZE)

# Fit linear model using new weights and new design
FIT = lmFit(VOOM.WEIGHTS$E,
            design = DESIGN$design,
            weights = VOOM.WEIGHTS$weights)
  
# Fit contrast
contrast = makeContrasts(contrasts=c("AOD.AD-AOD.CONTROL",
                                     "(AOD.AD+AOD.CONTROL)/2"),
                         levels = colnames(FIT$coefficients))
FIT.CONTR = contrasts.fit(FIT, contrasts=contrast)
FIT.CONTR = eBayes(FIT.CONTR)

# Get differential expression
DE = lapply(1:dim(contrast)[2], function(i, FIT){
  topTable(FIT, coef=i, number = 50000, confint = T) %>%
    rownameToFirstColumn('Tx.ID')
}, FIT.CONTR)
names(DE) = c('AOD.AD-AOD.CONTROL','AOD')

DE = DE %>% 
  rbindlist(idcol = 'Comparison') %>%
  dplyr::mutate(Study = 'ROSMAP', Region = 'DLPFC',
                Direction = logFC/abs(logFC),
                Direction = factor(Direction, c(-1,1), c('-1' = 'DOWN', '1' = 'UP')),
                Direction = as.character(Direction))
DE$Direction[DE$adj.P.Val > 0.05 | abs(DE$logFC) < log2(1.2)] = 'NONE'

writeLines('Differentially expressed genes at an FDR 0.05 and logFC 1.2')
tmp = DE %>%
  dplyr::select(Tx.ID, Comparison, Direction) %>%
  group_by(Comparison, Direction) %>%
  dplyr::summarise(FDR_0_05_FC_1.2 = length(unique(Tx.ID))) %>%
  spread(Direction, FDR_0_05_FC_1.2) 
kable(tmp)

p = ggplot(DE, aes(y = -log10(adj.P.Val), x = logFC, color = Direction)) + geom_point()
p = p + scale_color_manual(values = c('green','grey','red'))
p = p + facet_grid(.~Comparison, scales = 'free_x')
p

all.diff.exp = c(all.diff.exp, list(Diagnosis.AOD = DE))
all.fit = c(all.fit, list(Diagnosis.AOD = FIT))
```

### Store files in synapse
```{r synapse.store, include=FALSE, eval=TRUE, cache=FALSE}
# Function to change entity ACL (also creates new acls if it doesn't exist)
synChangeEntityACL <- function(id, new.racl){
  tryCatch({ 
    # If old acl exist update
    old.acl = synGetEntityACL(id)
    old.acl@resourceAccess = new.racl
    synUpdateEntityACL(old.acl)
  }, error = function(e){ 
    # If not create a new acl
    new.acl = AccessControlList(id = id, resourceAccess = new.racl)
    synCreateEntityACL(new.acl)
  })
}

# Set annotations
all.annotations = list(
  dataType = 'mRNA',
  dataSubType = 'isoformExp',
  summaryLevel = 'transcript',
  assay	 = 'RNAseq',
  assaySubType = 'Reprocessed',
  
  tissueTypeAbrv	= 'DLPFC', 
  study = 'ROSMAP', 
  center = 'BROAD-RUSH',
  
  organism = 'HomoSapiens',
  consortium	= 'AMP-AD',
   
  normalizationStatus	= TRUE,
  modelSystem	= FALSE,
  
  normalizationType	= 'TMM'
)

# Create new resource acls
new.racl = ResourceAccess(principalId = '3319864', 
                          accessType = c('UPDATE', 'CHANGE_SETTINGS', 'DELETE', 'READ', 'DOWNLOAD', 'MODERATE', 'CREATE', 'CHANGE_PERMISSIONS')) %>%
  ResourceAccessList() %>%
  synapseClient::append(ResourceAccess(principalId = '274008', 
                                       accessType = c('UPDATE', 'CHANGE_SETTINGS', 'DELETE', 'READ', 'DOWNLOAD', 'MODERATE', 'CREATE', 'CHANGE_PERMISSIONS'))) %>%
  synapseClient::append(ResourceAccess(principalId = '273995', 
                                       accessType = c('UPDATE', 'CHANGE_SETTINGS', 'DELETE', 'READ', 'DOWNLOAD', 'MODERATE', 'CREATE', 'CHANGE_PERMISSIONS'))) %>%
  synapseClient::append(ResourceAccess(principalId = '3344250', 
                                       accessType = c('READ', 'DOWNLOAD')))
  
# Code
CODE <- Folder(name = "ROSMAP Reprocessed Isoform (Normalised)", parentId = parentId)
annotations(CODE) = all.annotations
CODE <- synStore(CODE)
old.acl = synGetEntityACL(CODE@properties$id)
synChangeEntityACL(CODE@properties$id, new.racl)

# Store covariates
COVARIATES = rownameToFirstColumn(COVARIATES, 'SampleID')
write.table(COVARIATES, file = 'ROSMAP_DLPFC_Covariates.tsv', sep = '\t', row.names=F, quote=F)
COV_OBJ = File('ROSMAP_DLPFC_Covariates.tsv', name = 'Covariates', parentId = CODE$properties$id)
annotations(COV_OBJ) = annotations(CODE)
annotations(COV_OBJ)$dataSubType = 'covariates'
COV_OBJ = synStore(COV_OBJ, used = ALL_USED_IDs, activityName = activityName,
                   executed = thisFile, activityDescription = activityDescription)
synChangeEntityACL(COV_OBJ@properties$id, new.racl)

# Store filtered counts
PROCESSED_COUNTS$filteredExprMatrix$counts %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'ROSMAP_DLPFC_Counts.tsv', sep = '\t', row.names=F, quote=F)
COUNT_OBJ = File('ROSMAP_DLPFC_Counts.tsv', name = 'TPM (raw)', parentId = CODE$properties$id)
annotations(COUNT_OBJ) = annotations(CODE)
annotations(COUNT_OBJ)$dataSubType = 'filteredCounts'
COUNT_OBJ = synStore(COUNT_OBJ, activity = synGetActivity(COV_OBJ$properties$id))

# Store filtered counts
NEW.COUNTS %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'ROSMAP_DLPFC_eCounts.tsv', sep = '\t', row.names=F, quote=F)
ECOUNT_OBJ = File('ROSMAP_DLPFC_eCounts.tsv', name = 'TPM (estimated)', parentId = CODE$properties$id)
annotations(ECOUNT_OBJ) = annotations(CODE)
annotations(ECOUNT_OBJ)$dataSubType = 'estimatedCounts'
ECOUNT_OBJ = synStore(ECOUNT_OBJ, activity = synGetActivity(COV_OBJ$properties$id))

# Store logCPM
VOOM.GENE_EXPRESSION$E %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'ROSMAP_DLPFC_logCPM.tsv', sep = '\t', row.names=F, quote=F)
LCOUNT_OBJ = File('ROSMAP_DLPFC_logCPM.tsv', name = 'TPM (filtered)', parentId = CODE$properties$id)
annotations(LCOUNT_OBJ) = annotations(CODE)
annotations(LCOUNT_OBJ)$dataSubType = 'filteredLTPM'
LCOUNT_OBJ = synStore(LCOUNT_OBJ, activity = synGetActivity(COV_OBJ$properties$id))

# Store design matrix
MODEL1 %>%
  rownameToFirstColumn('SampleID') %>%
  write.table(file = 'ROSMAP_DLPFC_Design.tsv', sep = '\t', row.names=F, quote=F)
DM_OBJ = File('ROSMAP_DLPFC_Design.tsv', name = 'Design Matrix', parentId = CODE$properties$id)
annotations(DM_OBJ) = annotations(CODE)
annotations(DM_OBJ)$dataSubType = 'designMatrix'
DM_OBJ = synStore(DM_OBJ, activity = synGetActivity(COV_OBJ$properties$id))
synChangeEntityACL(DM_OBJ@properties$id, new.racl)

# Store differential expression results
rbindlist(all.diff.exp, use.names = T, fill = T, idcol = 'Model') %>%
  write.table(file = 'ROSMAP_DLPFC_DiffExpression.tsv', sep = '\t', row.names=F, quote=F)
DEXP_OBJ = File('ROSMAP_DLPFC_DiffExpression.tsv', name = 'Differential Expression Results (cogdx)', 
                parentId = CODE$properties$id)
annotations(DEXP_OBJ) = annotations(CODE)
annotations(DEXP_OBJ)$dataSubType = 'diffExp'
DEXP_OBJ = synStore(DEXP_OBJ, activity = synGetActivity(COV_OBJ$properties$id))

# Store all differential expression models
save(all.fit, file = 'ROSMAP_Models.RData')
FIT_OBJ = File('ROSMAP_Models.RData', 
               name = 'All Limma Models',
               parentId = CODE$properties$id)
annotations(FIT_OBJ) = annotations(CODE)
annotations(FIT_OBJ)$dataSubType = 'modelFits'
FIT_OBJ = synStore(FIT_OBJ, activity = synGetActivity(COV_OBJ$properties$id))
synChangeEntityACL(FIT_OBJ@properties$id, new.racl)

# Delete folder acl
synChangeEntityACL(CODE@properties$id, old.acl@resourceAccess)

stopCluster(cl)
```
|  *Results*                                  |  *SynapseID*                     |
|  -----------------------------------------  |   ---------                      |
|  Covariates (90+ ages)                      |  `r COV_OBJ$properties$id`       |
|  Counts (raw)                               |  `r COUNT_OBJ$properties$id`     |
|  Counts (estimated)                         |  `r ECOUNT_OBJ$properties$id`    |
|  Counts (lcpm)                              |  `r LCOUNT_OBJ$properties$id`    |
|  Design Matrix                              |  `r DM_OBJ$properties$id`        |
|  Differential Expression                    |  `r DEXP_OBJ$properties$id`      |
|  Linear Model Fits                          |  `r FIT_OBJ$properties$id`       |

### R Source Code
[Github](`r thisFile`)